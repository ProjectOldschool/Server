// Generated by delombok at Sat Feb 25 09:19:07 PST 2017
package astraeus.game.model.entity.mob;

import java.util.ArrayDeque;
import java.util.Deque;
import java.util.EnumSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Optional;
import java.util.PriorityQueue;
import java.util.Queue;
import astraeus.GameEngine;
import astraeus.game.model.Animation;
import astraeus.game.model.Graphic;
import astraeus.game.model.Position;
import astraeus.game.model.World;
import astraeus.game.model.entity.Entity;
import astraeus.game.model.entity.EntityType;
import astraeus.game.model.entity.item.Item;
import astraeus.game.model.entity.mob.combat.Combat;
import astraeus.game.model.entity.mob.combat.dmg.Hit;
import astraeus.game.model.entity.mob.combat.dmg.Poison.DamageTypes;
import astraeus.game.model.entity.mob.npc.Npc;
import astraeus.game.model.entity.mob.player.ForceMovement;
import astraeus.game.model.entity.mob.player.Player;
import astraeus.game.model.entity.mob.player.attr.AttributeMap;
import astraeus.game.model.entity.mob.player.skill.SkillSet;
import astraeus.game.model.entity.mob.update.UpdateFlag;
import astraeus.game.model.entity.object.GameObject;
import astraeus.game.task.Task;
import astraeus.util.Stopwatch;

/**
 * The class that represents a mobile entity that is either a NPC (Non-Playable-Character) or
 * Player.
 *
 * @author Vult-R
 */
public abstract class Mob extends Entity {
  private final List<Player> localPlayers = new LinkedList<Player>();
  private final List<Npc> localNpcs = new LinkedList<Npc>();
  protected final EnumSet<UpdateFlag> updateFlags = EnumSet.noneOf(UpdateFlag.class);
  private final Queue<Animation> animations = new PriorityQueue<>();
  private final Queue<Graphic> graphics = new PriorityQueue<>();
  protected final AttributeMap attr = new AttributeMap();
  protected final Combat combat = new Combat(this);
  private SkillSet skills = new SkillSet(this);
  private Position lastPosition = new Position(0, 0, 0);
  protected Position createdPosition;
  private DamageTypes poisonType;
  protected int slot;
  private Position facingLocation;
  protected final Movement movement = new Movement(this);
  private ForceMovement forceMovement;
  private Mob interactingEntity;
  private Optional<Task> currentAction = Optional.empty();
  protected final Deque<Hit> hitQueue = new ArrayDeque<>();
  private int antipoisonTimer = 0;
  private int id;
  protected int size = 1;
  private int walkingDirection = -1;
  private int runningDirection = -1;
  private Stopwatch lastPoisoned = new Stopwatch();
  private final MobAnimation mobAnimation = new MobAnimation();
  private boolean registered;
  private boolean poisoned;
  private boolean isDead;
  private boolean regionChange;
  private boolean teleporting;
  private boolean visible;
  private boolean following;
  private String forcedChat;
  private int immunity;
  
  public Mob(Position position) {
    this.position = position;
  }
  
  /**
   * The method called on a game tick.
   */
  public abstract void onTick();
  
  public abstract int getCurrentHealth();
  private static int tick = GameEngine.tick;
  
  /**
   * The method that increments tick to time actions
   */
  protected void tick() {
    tick = GameEngine.tick;
    onTick();
    if (tick >= 1000) {
      tick = 0;
    }
  }
  
  /**
   * Gets the maximum number of hitpoints an entity has.
   */
  public abstract int getMaximumHealth();
  
  /**
   * The method called before the mob is updated.
   */
  public abstract void preUpdate();
  
  /**
   * The method called during an update. This should only be used for a player, since a player will
   * send the PlayerUpdatePacket, and NpcUpdatePacket right after it.
   */
  public void update() {
  }
  
  /**
   * The method called after a mob is updated.
   */
  public abstract void postUpdate();
  
  /**
   * The method called when an entity dies.
   */
  public abstract void onDeath();
  
  /**
   * The method called when an entity walks or runs.
   */
  public abstract void onMovement();
  
  public abstract void dealDamage(Mob attacker, Hit hit);
  
  public void startAction(Task currentAction) {
    this.currentAction.ifPresent(it -> {
      if (it.equals(currentAction)) {
        return;
      }
      stopAction();
    });
    this.currentAction = Optional.of(currentAction);
    World.submit(currentAction);
  }
  
  public void stopAction() {
    currentAction.ifPresent(it -> {
      it.setInterrupt(true);
      it.stop();
      currentAction = Optional.empty();
    });
  }
  
  public AttributeMap attr() {
    return attr;
  }
  
  /**
   * Determines if this {@link Player} can logout.
   *
   * @return {@code true} If this player can logout. {@code false} Otherwise.
   */
  public boolean canLogout() {
    return true;
  }
  
  public boolean canTeleport() {
    return true;
  }
  
  public boolean canClickButton() {
    return true;
  }
  
  public boolean canTrade() {
    return true;
  }
  
  public boolean canDuel() {
    return true;
  }
  
  public boolean canAttackMob(Npc mob) {
    return true;
  }
  
  public boolean canAttackPlayer(Player player) {
    return true;
  }
  
  public boolean canClickMob(Npc mob) {
    return true;
  }
  
  public boolean canClickObject(GameObject object) {
    return true;
  }
  
  public boolean canDrink() {
    return true;
  }
  
  public boolean canEat() {
    return true;
  }
  
  public boolean canDrop() {
    return true;
  }
  
  public boolean canMove() {
    return true;
  }
  
  public boolean canPickup(Item item) {
    return true;
  }
  
  public boolean canSave() {
    return true;
  }
  
  public boolean canPray() {
    return true;
  }
  
  public boolean canTalk() {
    return true;
  }
  
  public boolean canUnequip(Item item) {
    return true;
  }
  
  public boolean canUseSpecial() {
    return true;
  }
  
  public Npc getNpc() {
    return World.getNpcs().get(slot);
  }
  
  public Player getPlayer() {
    return World.getPlayers().get(slot);
  }
  
  public int getSize() {
    return size;
  }
  
  public boolean isUpdateRequired() {
    return !updateFlags.isEmpty();
  }
  
  public boolean isNpc() {
    return type() == EntityType.NPC;
  }
  
  public boolean isPlayer() {
    return type() == EntityType.PLAYER;
  }
  
  @Override
  public boolean isMob() {
    return getClass() == Mob.class;
  }
  
  public void resetEntityInteraction() {
    if (this.getInteractingEntity() != null) {
      this.getInteractingEntity().setInteractingEntity(null);
      this.interactingEntity = null;
    }
    updateFlags.add(UpdateFlag.ENTITY_INTERACTION);
  }
  
  public void setForcedChat(String forcedChat) {
    this.forcedChat = forcedChat;
    updateFlags.add(UpdateFlag.FORCED_CHAT);
  }
  
  public void setInteractingEntity(Mob entity) {
    this.interactingEntity = entity;
    updateFlags.add(UpdateFlag.ENTITY_INTERACTION);
  }
  private final Stopwatch lastAnimation = new Stopwatch();
  
  public void startAnimation(final Animation animation) {
    startAnimation(animation, 0);
  }
  
  public void startAnimation(final Animation animation, int delay) {
    if (lastAnimation.elapsed() < delay) {
      return;
    }
    if (animation != null) {
      animations.add(animation);
      updateFlags.add(UpdateFlag.ANIMATION);
      lastAnimation.reset();
    }
  }
  
  public void startGraphic(Graphic graphic) {
    startGraphic(graphic, 0);
  }
  
  public void startGraphic(Graphic graphic, int delay) {
    if (lastAnimation.elapsed() < delay) {
      return;
    }
    if (graphic != null) {
      graphics.add(graphic);
      updateFlags.add(UpdateFlag.GRAPHICS);
      lastAnimation.reset();
    }
  }
  
  public void setForceMovement(ForceMovement forceMovement) {
    this.forceMovement = forceMovement;
    updateFlags.add(UpdateFlag.FORCE_MOVEMENT);
  }
  
  public void faceLocation(Position facingLocation) {
    this.facingLocation = facingLocation;
    updateFlags.add(UpdateFlag.FACE_COORDINATE);
  }
  
  public Animation getAnimation() {
    return animations.peek() == null ? new Animation(65535) : animations.peek();
  }
  
  public Graphic getGraphic() {
    return graphics.peek() == null ? new Graphic(65535) : graphics.peek();
  }
  
  @Override
  public boolean equals(Object o) {
    if (o == null) {
      return false;
    }
    if (o instanceof Mob) {
      Mob entity = (Mob)o;
      return hashCode() == entity.hashCode();
    }
    return false;
  }
  
  @java.lang.SuppressWarnings("all")
  @javax.annotation.Generated("lombok")
  public List<Player> getLocalPlayers() {
    return this.localPlayers;
  }
  
  @java.lang.SuppressWarnings("all")
  @javax.annotation.Generated("lombok")
  public List<Npc> getLocalNpcs() {
    return this.localNpcs;
  }
  
  @java.lang.SuppressWarnings("all")
  @javax.annotation.Generated("lombok")
  public EnumSet<UpdateFlag> getUpdateFlags() {
    return this.updateFlags;
  }
  
  @java.lang.SuppressWarnings("all")
  @javax.annotation.Generated("lombok")
  public Queue<Animation> getAnimations() {
    return this.animations;
  }
  
  @java.lang.SuppressWarnings("all")
  @javax.annotation.Generated("lombok")
  public Queue<Graphic> getGraphics() {
    return this.graphics;
  }
  
  @java.lang.SuppressWarnings("all")
  @javax.annotation.Generated("lombok")
  public AttributeMap getAttr() {
    return this.attr;
  }
  
  @java.lang.SuppressWarnings("all")
  @javax.annotation.Generated("lombok")
  public Combat getCombat() {
    return this.combat;
  }
  
  @java.lang.SuppressWarnings("all")
  @javax.annotation.Generated("lombok")
  public SkillSet getSkills() {
    return this.skills;
  }
  
  @java.lang.SuppressWarnings("all")
  @javax.annotation.Generated("lombok")
  public void setSkills(final SkillSet skills) {
    this.skills = skills;
  }
  
  @java.lang.SuppressWarnings("all")
  @javax.annotation.Generated("lombok")
  public Position getLastPosition() {
    return this.lastPosition;
  }
  
  @java.lang.SuppressWarnings("all")
  @javax.annotation.Generated("lombok")
  public void setLastPosition(final Position lastPosition) {
    this.lastPosition = lastPosition;
  }
  
  @java.lang.SuppressWarnings("all")
  @javax.annotation.Generated("lombok")
  public Position getCreatedPosition() {
    return this.createdPosition;
  }
  
  @java.lang.SuppressWarnings("all")
  @javax.annotation.Generated("lombok")
  public void setCreatedPosition(final Position createdPosition) {
    this.createdPosition = createdPosition;
  }
  
  @java.lang.SuppressWarnings("all")
  @javax.annotation.Generated("lombok")
  public DamageTypes getPoisonType() {
    return this.poisonType;
  }
  
  @java.lang.SuppressWarnings("all")
  @javax.annotation.Generated("lombok")
  public void setPoisonType(final DamageTypes poisonType) {
    this.poisonType = poisonType;
  }
  
  @java.lang.SuppressWarnings("all")
  @javax.annotation.Generated("lombok")
  public int getSlot() {
    return this.slot;
  }
  
  @java.lang.SuppressWarnings("all")
  @javax.annotation.Generated("lombok")
  public void setSlot(final int slot) {
    this.slot = slot;
  }
  
  @java.lang.SuppressWarnings("all")
  @javax.annotation.Generated("lombok")
  public Position getFacingLocation() {
    return this.facingLocation;
  }
  
  @java.lang.SuppressWarnings("all")
  @javax.annotation.Generated("lombok")
  public Movement getMovement() {
    return this.movement;
  }
  
  @java.lang.SuppressWarnings("all")
  @javax.annotation.Generated("lombok")
  public ForceMovement getForceMovement() {
    return this.forceMovement;
  }
  
  @java.lang.SuppressWarnings("all")
  @javax.annotation.Generated("lombok")
  public Mob getInteractingEntity() {
    return this.interactingEntity;
  }
  
  @java.lang.SuppressWarnings("all")
  @javax.annotation.Generated("lombok")
  public Optional<Task> getCurrentAction() {
    return this.currentAction;
  }
  
  @java.lang.SuppressWarnings("all")
  @javax.annotation.Generated("lombok")
  public void setCurrentAction(final Optional<Task> currentAction) {
    this.currentAction = currentAction;
  }
  
  @java.lang.SuppressWarnings("all")
  @javax.annotation.Generated("lombok")
  public Deque<Hit> getHitQueue() {
    return this.hitQueue;
  }
  
  @java.lang.SuppressWarnings("all")
  @javax.annotation.Generated("lombok")
  public int getAntipoisonTimer() {
    return this.antipoisonTimer;
  }
  
  @java.lang.SuppressWarnings("all")
  @javax.annotation.Generated("lombok")
  public void setAntipoisonTimer(final int antipoisonTimer) {
    this.antipoisonTimer = antipoisonTimer;
  }
  
  @java.lang.SuppressWarnings("all")
  @javax.annotation.Generated("lombok")
  public int getId() {
    return this.id;
  }
  
  @java.lang.SuppressWarnings("all")
  @javax.annotation.Generated("lombok")
  public void setId(final int id) {
    this.id = id;
  }
  
  @java.lang.SuppressWarnings("all")
  @javax.annotation.Generated("lombok")
  public int getWalkingDirection() {
    return this.walkingDirection;
  }
  
  @java.lang.SuppressWarnings("all")
  @javax.annotation.Generated("lombok")
  public void setWalkingDirection(final int walkingDirection) {
    this.walkingDirection = walkingDirection;
  }
  
  @java.lang.SuppressWarnings("all")
  @javax.annotation.Generated("lombok")
  public int getRunningDirection() {
    return this.runningDirection;
  }
  
  @java.lang.SuppressWarnings("all")
  @javax.annotation.Generated("lombok")
  public void setRunningDirection(final int runningDirection) {
    this.runningDirection = runningDirection;
  }
  
  @java.lang.SuppressWarnings("all")
  @javax.annotation.Generated("lombok")
  public Stopwatch getLastPoisoned() {
    return this.lastPoisoned;
  }
  
  @java.lang.SuppressWarnings("all")
  @javax.annotation.Generated("lombok")
  public MobAnimation getMobAnimation() {
    return this.mobAnimation;
  }
  
  @java.lang.SuppressWarnings("all")
  @javax.annotation.Generated("lombok")
  public boolean isRegistered() {
    return this.registered;
  }
  
  @java.lang.SuppressWarnings("all")
  @javax.annotation.Generated("lombok")
  public void setRegistered(final boolean registered) {
    this.registered = registered;
  }
  
  @java.lang.SuppressWarnings("all")
  @javax.annotation.Generated("lombok")
  public boolean isPoisoned() {
    return this.poisoned;
  }
  
  @java.lang.SuppressWarnings("all")
  @javax.annotation.Generated("lombok")
  public void setPoisoned(final boolean poisoned) {
    this.poisoned = poisoned;
  }
  
  @java.lang.SuppressWarnings("all")
  @javax.annotation.Generated("lombok")
  public boolean isDead() {
    return this.isDead;
  }
  
  @java.lang.SuppressWarnings("all")
  @javax.annotation.Generated("lombok")
  public void setDead(final boolean isDead) {
    this.isDead = isDead;
  }
  
  @java.lang.SuppressWarnings("all")
  @javax.annotation.Generated("lombok")
  public boolean isRegionChange() {
    return this.regionChange;
  }
  
  @java.lang.SuppressWarnings("all")
  @javax.annotation.Generated("lombok")
  public void setRegionChange(final boolean regionChange) {
    this.regionChange = regionChange;
  }
  
  @java.lang.SuppressWarnings("all")
  @javax.annotation.Generated("lombok")
  public boolean isTeleporting() {
    return this.teleporting;
  }
  
  @java.lang.SuppressWarnings("all")
  @javax.annotation.Generated("lombok")
  public void setTeleporting(final boolean teleporting) {
    this.teleporting = teleporting;
  }
  
  @java.lang.SuppressWarnings("all")
  @javax.annotation.Generated("lombok")
  public boolean isVisible() {
    return this.visible;
  }
  
  @java.lang.SuppressWarnings("all")
  @javax.annotation.Generated("lombok")
  public void setVisible(final boolean visible) {
    this.visible = visible;
  }
  
  @java.lang.SuppressWarnings("all")
  @javax.annotation.Generated("lombok")
  public boolean isFollowing() {
    return this.following;
  }
  
  @java.lang.SuppressWarnings("all")
  @javax.annotation.Generated("lombok")
  public void setFollowing(final boolean following) {
    this.following = following;
  }
  
  @java.lang.SuppressWarnings("all")
  @javax.annotation.Generated("lombok")
  public String getForcedChat() {
    return this.forcedChat;
  }
  
  @java.lang.SuppressWarnings("all")
  @javax.annotation.Generated("lombok")
  public int getImmunity() {
    return this.immunity;
  }
  
  @java.lang.SuppressWarnings("all")
  @javax.annotation.Generated("lombok")
  public void setImmunity(final int immunity) {
    this.immunity = immunity;
  }
  
  @java.lang.SuppressWarnings("all")
  @javax.annotation.Generated("lombok")
  public static int getTick() {
    return Mob.tick;
  }
}